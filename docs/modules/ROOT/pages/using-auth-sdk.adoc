= AeroGear Services Auth SDK

Mobile authentication SDK based on link:http://www.keycloak.org/[Keycloak] using link:http://openid.net/connect/[OpenID Connect].

Provides authentication features like access control and two factor authentication through Keycloak.

image::https://img.youtube.com/vi/MGecRG11k6E/0.jpg[title="Demo Video (https://www.youtube.com/watch?v=MGecRG11k6E)", link="https://www.youtube.com/watch?v=MGecRG11k6E",caption=""]

== Usage

To use the Auth SDK you'll first need to:

* Have a Keycloak instance. See <<Setting up Keycloak>>.
* Import the Core module.
* A configuration file added to the apps assets directory. See <<Configuration file>>
* Specify the schema of the redirect url for your Android project in `android.defaultConfig.manifestPlaceholders` of the apps `build.gradle` file.
It should match the schema specified in the `Valid Redirect URL` section for the client in Keycloak.
It is recommended to use the package name of the Android app as the schema of the redirect url to avoid conflicts.
See link:../../example/src/build.gradle[the example app build.gradle file].

=== Setting up Keycloak

==== Using OpenShift

* If you do not have mobile services enabled in your openshift cluster follow this link:https://github.com/aerogear/mobile-core/blob/master/docs/walkthroughs/local-setup.adoc[Local Setup] guide.
* Navigate to your Openshift cluster and in the Service Catalog search for the Keycloak service.
* Click on the Keycloak service and you will be prompted to fill in details about your app.  For now you can leave these as they are.  Navigate through the setup and click Create.
This will provision the Keycloak service in the project you specified and create a public Client to be used with an app along with a bearer-only client.
See link:http://www.keycloak.org/docs/latest/server_admin/index.html#oidc-clients[Keycloak OIDC client documentation].

After provisioning, the Keycloak service will be available at the exposed Route. You can view this route inside your project or use the below command to get the route:
----
oc get route keycloak --template "http://{{.spec.host}} "
----
The route should look like `https://keycloak-myproject.192.168.37.1.nip.io/auth/`. +

==== Standalone

To setup standalone Keycloak follow Keycloak's guide link:/https://github.com/keycloak/keycloak/blob/master/README.md[here].

=== Adding dependency

Add dependency to your application module
----
dependencies {
    implementation "org.aerogear:aerogear-auth:[version]"
}
----

=== Configuration file

A `mobile-services.json` file must exist in the apps assets directory. It should specify configuration
for Keycloak. This configuration can be generated by the link:https://github.com/aerogear/mobile-cli[AeroGear Mobile CLI].

For an example of Keycloak configuration see link:../../example/src/main/assets/mobile-services.json[example apps mobile-services.json].

The Auth SDK will use this configuration to communicate with Keycloak.

=== Initializing the SDK

Before initializing the auth service, the auth service and browser to be used during authentication need be configured.

==== AuthServiceConfiguration

[source, java]
----
// build the AuthServiceConfiguration and specify redirect URI. It is recommended to use the package name of your app.
AuthServiceConfiguration authServiceConfig = new AuthServiceConfiguration
    .AuthConfigurationBuilder()
    .withRedirectUri("org.aerogear.mobile.example:/callback")
    .build();
----

==== Browser

The `Browser` builder allows for browsers to be configured and later these browsers can or cannot be used during authentication (whitelisted or blacklisted).  

There are 3 browsers supported; Google Chrome, Mozilla Firefox and Samsung Browser.  Each browser can be configured to be used as a standalone browser or a custom tab browser.  It's also possible to specifiy the version(s) of the browser that should be used. There are different options available for all 3 browsers, which are defined in `BrowserType`:

===== Chrome (`BrowserType.CHROME`)

This represents a Google Chrome browser where the browser can be configured to be used as a standalone browser or a custom tab browser and versions can also be specified.

[source, java]
----
// a Google Chrome browser configured to be used as a custom tab and version of the browser must be at least 45
Browser chromeBrowser = new Browser.BrowserBuilder().browser(BrowserType.CHROME).customTab(true).versionRangeAtLeast("45").build();
----

===== Firefox (`BrowserType.FIREFOX`)

This represents a Mozilla Firefox browser where the browser can be configured to be used as a standalone browser or a custom tab browser and versions can also be specified.

[source, java]
----
// a Mozilla Firefox browser configured to be used as a standalone browser and the version of the browser to be used can be anything from 55 to 60
Browser firefoxBrowser = new Browser.BrowserBuilder().browser(BrowserType.FIREFOX).customTab(false).versionRangeBetween("55", "60").build();
----

===== Samsung Browser (`BrowserType.SAMSUNG_BROWSER`)

This represents a Samsung browser where the browser can be configured to be used as a standalone browser or a custom tab browser and versions can also be specified.

[source, java]
----
// a Samsung browser configured to be used as a standalone browser and the version of the browser to be used must be at least 6
Browser samsungBrowser = new Browser.BrowserBuilder().browser(BrowserType.SAMSUNG_BROWSER).customTab(false).versionRangeAtLeast("6.0").build();
----

===== Chrome Default (`BrowserType.CHROME_DEFAULT`)

This represents any version of a Google Chrome browser where the browser is configured to be used as a standalone browser.

[source, java]
----
Browser chromeDefaultBrowser = new Browser.BrowserBuilder().browser(BrowserType.CHROME_DEFAULT).build();
----

===== Chrome Default Custom Tab (`BrowserType.CHROME_DEFAULT_CUSTOM_TAB`)

This represents a Google Chrome browser for use as a custom tab and the minimum version specified is 45 (its only possible to configure custom tab use in version 45 and up).

[source, java]
----
Browser chromeDefaultCustomTabBrowser = new Browser.BrowserBuilder().browser(BrowserType.CHROME_DEFAULT_CUSTOM_TAB).build();
----

===== Firefox Default (`BrowserType.FIREFOX_DEFAULT`)

This represents any version of a Mozilla Firefox browser for use as a standalone browser.

[source, java]
----
Browser firefoxDefaultBrowser = new Browser.BrowserBuilder().browser(BrowserType.FIREFOX_DEFAULT).build();
----

===== Samsung Browser Default (`BrowserType.SAMSUNG_BROWSER_DEFAULT`)

This represents any version of a Samsung browser for use as a standalone browser.

[source, java]
----
Browser samsungBrowserDefault = new Browser.BrowserBuilder().browser(BrowserType.SAMSUNG_BROWSER_DEFAULT).build(); 
----

===== Samsung Browser Default Custom Tab (`BrowserType.SAMSUNG_BROWSER_DEFAULT_CUSTOM_TAB`)

This represents any version of a Samsung browser for use as a custom tab.

[source, java]
----
Browser samsungBrowserDefaultCustomTab = new Browser.BrowserBuilder().browser(BrowserType.SAMSUNG_BROWSER_DEFAULT_CUSTOM_TAB).build();
----

==== Browser Configuration
Once a browser or browsers have been configured, the `BrowserConfiguration` builder can be used to either blacklist or whitelist these browsers.

IMPORTANT: It's only possible to blacklist or whitelist a browser/browsers. It is not possible to both whitelist and blacklist a browser/browsers.  If both are invoked the most previous browser configuration built will be used.

[source, java]
----
// blacklist any version of a Samsung browser for use as a custom tab.
Browser samsungBrowser = new Browser.BrowserBuilder().browser(BrowserType.SAMSUNG_BROWSER).customTab(true).versionRangeAnyVersion().build();
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder().blackList().browser(samsungBrowserDefaultCustomTab).build();

// whitelist a Google Chrome browser for use as a custom tab where the minimum version is 45
Browser chromeDefaultCustomTabBrowser = new Browser.BrowserBuilder().browser(BrowserType.CHROME_DEFAULT_CUSTOM_TAB).build();
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder().whitelist().browser(chromeDefaultCustomTabBrowser).build();

// blacklist the two browsers configured above
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder().blacklist().browser(chromeDefaultCustomTabBrowser).browser(samsungBrowserDefaultCustomTab).build();

// add the two browsers configured above to a Set
Set<Browser> browsers = new HashSet<>(Arrays.asList(samsungBrowserDefaultCustomTab, chromeDefaultCustomTabBrowser));
// whitelist this Set of browsers
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder().whiteList().browsers(browsers).build();
----

==== Auth Service Initialisation
`AuthService` can be retrieved using the `MobileCore#getInstance` method.

[source,java]
----
AuthService authService = MobileCore.getInstance().getService(AuthService.class);
----

Any subsequent `getService` call will return the same instance of `AuthService`.

Before the `AuthService` can be used `AuthService#init` must be invoked once in an app.

`AuthService#init` method expects `AuthServiceConfiguration` and `BrowserConfiguration` as parameters so these configurations need to be initialized first.


[source,java]
----
// auth service configuration
AuthServiceConfiguration authServiceConfig = new AuthServiceConfiguration
    .AuthConfigurationBuilder()
    .withRedirectUri("org.aerogear.mobile.example:/callback")
    .build();

// browser configuration
Browser browser = new Browser.BrowserBuilder().browser(BrowserType.CHROME_DEFAULT_CUSTOM_TAB).build();
BrowserConfiguration browserConfiguration = new BrowserConfiguration.BrowserConfigurationBuilder().blackList().browser(browser).build();

// You only need to invoke this once every subsequent retrieval of the AuthService 
// will retrieve the same instance.
authService.init(context, authServiceConfig, browserConfiguration);
----

==== Defining Custom Scopes
Optionally, scopes can be defined for the auth request using a space as the delimiter as per https://tools.ietf.org/html/rfc6749#section-3.3[RFC-6749].
By default, the `"openid"` scope is sent if no scopes are defined.
[source,java]
----
// default is 'openid' when not defined
.withScopes("openid offline_access")
----

If `AuthService#init` is not invoked then an `IllegalStateException` will be thrown when using the
service.

=== Retrieving the current user

To retrieve the current authenticated user the `AuthService#currentUser` method can be invoked. This will be `null` if there is
no user authenticated. So it can be used to check whether to start the authentication flow or not.

[source,java]
----
// authService already initialized.
UserPrincipal currentUser = authService.currentUser();

if (currentUser != null) {
    // User is authenticated, get the users username
    String userName = currentUser.getUsername();
    // Get the users first name
    String firstName = currentUser.getFirstName();
    // Get the users last name
    String lastName = currentUser.getLastName();
    // Get the users email address
    String userEmail = currentUser.getEmail();
    // Get the access token of the authenticated user
    String accessToken = currentUser.getAccessToken();
    // Get the identity token of the authenticated user
    String identityToken = currentUser.getIdentityToken();
    // Get the refresh token of the authenticated user
    String refreshToken = currentUser.getRefreshToken();
} else {
    // User is not authenticated, start authentication flow
}
----

==== Retrieving Custom User Attributes

A walkthrough has been provided in the link:./auth-user-attributes.adoc[Keycloak Custom User Attributes] document to show how you can allow custom user attributes in Keycloak to be available in the Identity token.

You can then retrieve the custom attributes from the current user.

[source,java]
----
boolean booleanAttribute = currentUser.getCustomBooleanAttribute("booleanAttribute");
int intAttribute = currentUser.getCustomIntegerAttribute("intAttribute");
long longAttribute = currentUser.getCustomLongAttribute("longAttribute");
String stringAttribute = currentUser.getCustomStringAttribute("stringAttribute");

----

=== Authenticating

To start the authentication invoke the `AuthService#login` method.

[source,java]
----
// authService already initialized.
AuthService authService = MobileCore.getInstance().getService(AuthService.class);

static int LOGIN_RESULT_CODE = 1;

// Build the options object and start the authentication flow. 
// Provide an activity to handle the auth response.
DefaultAuthenticateOptions options = 
    new DefaultAuthenticateOptions(myActivity, LOGIN_RESULT_CODE);

Callback authCallback = new Callback<UserPrincipal>() {
    @Override
    public void onSuccess(UserPrincipal principal) {
        // User authenticated in, continue on..
    }

    @Override
    public void onError(Throwable error) {
        // An error occurred during login.
    }
};

authService.login(options, authCallback);
----

Once the browser returns to the app the result can be handled. In the activity provided to the
`login` method override `onActivityResult`. This handler should always invoke
`AuthService#handleAuthResponse`, providing the `Intent`. This will exchange the temporary tokens
returned from `AuthService#login` for long-life tokens and will provide a `UserPrincipal` which can
be used to access a users details. If this is not invoked you will not have access to the
`UserPrincipal`.

More information about the user returned is available in link:../core/README.adoc[the auth module JavaDocs].

[source,java]
----
@Override
public void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == LOGIN_RESULT_CODE) {
        // The core will return the same instance of the auth service as before
        AuthService authService = mobileCore.getInstance(AuthService.class);
        authService.handleAuthResult(data);
    }
}
----

The callback provided in `AuthService#login` will be invoked.

=== Retrieving a users roles

Once a `UserPrincipal` has been retrieved the link:http://www.keycloak.org/docs/latest/server_admin/index.html#roles[roles] of the user can be listed and checked. This can
be used to perform client side access control, such as hiding UI components related to actions the
user doesn't have permissions to perform.

To list a users roles the `UserPrincipal#getRoles` method can be invoked.

Roles are divided into two types. Resource roles which belong to the client the user has
authenticated against, and Realm roles which belong to the realm the client is in.

To list a users realm roles  the `UserPrincipal#getRealmRoles` method can be invoked and 
to list a users resource roles the `UserPrincipal#getResourceRoles` can be invoked.

In order to check if a user has a specific role you can invoke the `UserPrincipal#hasResourceRole`
and `UserPrincipal#hasRealmRole` methods and provide the role name to check for.

[source,java]
----
// authService already initialized.
AuthService authService = MobileCore.getInstance().getService(AuthService.class);
UserPrincipal currentUser = authService.currentUser();

boolean hasAdminPermissions = currentUser.hasRealmRole("user_admin");
if (hasAdminPermissions) {
    // Show some component.
}

// Check if a user has a role from a specific resource named my_resource.
boolean isModerator = currentUser.hasResourceRole("my_resource", "user_moderator");
if (isModerator) {
    // Enable some button.
}
----

=== Logging out

To logout, invoke the `AuthService#logout` method. This accepts the `UserPrincipal` that was
provided by `AuthService#handleAuthResponse` and has a callback to determine if the logout to the Keycloak or OpenID Connect server was successful.

[source,java]
----
// authService already initialized.
AuthService authService = MobileCore.getInstance().getService(AuthService.class);
UserPrincipal currentUser = authService.currentUser();

authService.logout(currentUser, new Callback<UserPrincipal>() {
    @Override
    public void onSuccess() {
        // User Logged Out Successfully and Local Auth Tokens were Deleted
    }

    @Override
    public void onError(Throwable error) {
        // An error occurred during logout
    }
});
----

By default, the local tokens obtained during authentication are only deleted when the logout succeeded against the authentication server.
You can use the `AuthService#deleteTokens` function to delete the local authentication tokens as part of a failed logout, or for other use cases.

*Note:* To perform backchannel or federated logouts, you must enable the Backchannel Logout option for the federated identity provider. More information is available in the Keycloak documentation under  http://www.keycloak.org/docs/latest/server_admin/index.html#openid-connect-v1-0-identity-providers[OIDC Identity Providers].

=== Single Sign-on
A walkthrough on how to setup Single Sign-on across Android Applications can be seen under the link:./auth-single-sign-on.adoc[Single Sign-on Documentation].
